### 3. 无重复字符的最长子串（中等）
#### 题目描述
给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
##### 示例1
```bash
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
##### 示例2
```bash
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
##### 示例2
```bash
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```
#### 代码
刚看完题目描述的我觉得这道题目好像很简单啊，用第一题时候一样的字典查找就可以解决了，最后题目给的三个例子倒是通过了，提交检测的几百上千个测试用例却总有通不过的，为了涵盖不同的测试用例代码被我改的又臭又长，折腾了一段时间只好打开了百度放弃了挣扎...所以说到底我的代码能力是真滴弱啊...因此直接附上大佬们的代码吧...

因为无重复子串可能从开头开始，也可能在中间，也可能直到末尾，因此我们只能遍历完整个字符串，所以从头开始遍历的时候，将不重复的字符放入字典中，并储存其下一个位置的字符的下标，这样一来，当我们遇到下一个与字典中字符重复的字符的时候，就可以取出该重复字符在字典中的value，把它作为新的开始，计算ans，另外需要注意一点的是，新的开始下标一定要是最靠后的，且循环每轮都需要更新value，如此直到字符串结束。
```python
class Solution:
    def lengthOfLongestSubstring(self, s):
        dict1 = {} #定义一个字典用来查找
        i , ans = 0, 0 #i代表重复的最后的位置，ans为结果
        for j in range(len(s)):
            if s[j] in dict1:
                i = max(dict1[s[j]],i) #取重复的最后面的字符位置
                #i = dict1[s[j]]
            ans = max(ans, j-i+1) #取最大的子序列长度
            dict1[s[j]] = j+1 #将不在字典中的也就是不重复的字母放入字典，每轮都需要更新value
        return ans
```
最后反思一下自己为什么想不到为什么想不到......